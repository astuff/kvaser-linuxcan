<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sending and Receiving</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="kvaser.gif"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_user_guide_send_recv.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Sending and Receiving </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#section_user_guide_send_recv_bus_on_off">Bus On / Bus Off</a></li>
<li class="level1"><a href="#section_user_guide_send_recv_reading">Reading Messages</a></li>
<li class="level1"><a href="#section_user_guide_send_recv_sending">Sending Messages</a></li>
<li class="level1"><a href="#section_user_guide_send_recv_asynch_not">Asynchronous Notification</a></li>
<li class="level1"><a href="#section_user_guide_send_recv_filters">Message Filters</a></li>
<li class="level1"><a href="#section_user_guide_send_recv_mailboxes">Message Mailboxes</a></li>
<li class="level1"><a href="#section_user_guide_send_recv_overruns">Overruns</a></li>
<li class="level1"><a href="#section_user_guide_send_recv_queue_and_buf_sizes">Message Queue and Buffer Sizes</a></li>
<li class="level1"><a href="#section_user_guide_send_recv_obj_buf">Object Buffers</a></li>
<li class="level1"><a href="#section_user_guide_send_recv_sending_different_types">Different CAN Frame Types</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="section_user_guide_send_recv_bus_on_off"></a>
Bus On / Bus Off</h1>
<p>When the CAN controller is on bus, it is receiving messages and is sending acknowledge bits in response to all correctly received messages.</p>
<p>A controller that is off bus is not taking part in the bus communication at all.</p>
<p>Use <a class="el" href="group___c_a_n.html#ga99c7c99cc71580f8099a1407f4f9ea1a">canBusOn()</a> to go on bus and <a class="el" href="group___c_a_n.html#gaf1786cfbfd542b18b9c599d278837bd9">canBusOff()</a> to go off bus.</p>
<p>You can set a channel to silent mode if you want it to be on-bus without interfering with the traffic in any way. A channel in silent mode will receive everything on the bus but will not transmit anything, not even ACK bits. Use <a class="el" href="group___c_a_n.html#gafca31590718ac7101d065b0c18b2410e">canSetBusOutputControl()</a> to set a channel to silent mode.</p>
<h1><a class="anchor" id="section_user_guide_send_recv_reading"></a>
Reading Messages</h1>
<p>Incoming messages are placed in a queue in the driver. In most cases the hardware does message buffering as well. You can read the first message in the queue by calling <a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead</a>; it will return <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a734089f351bc421c230bf8b6cd9b1e8e">canERR_NOMSG</a> if there was no message available.</p>
<p>The flag parameter of <a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead</a> contains a combination of the <a class="el" href="canstat_8h.html#canMSG_xxx">canMSG_xxx</a> flags and provides you with more information about the message; for example, a frame with a 29-bit identifier will have the <a class="el" href="canstat_8h.html#ade936f23b4b303d64187b4c6589c9c10">canMSG_EXT</a> bit set, and a remote frame will have the <a class="el" href="canstat_8h.html#a687df04559a9995e0bec503655454eb3">canMSG_RTR</a> bit set. Note that the flag argument is a combination of the <a class="el" href="canstat_8h.html#canMSG_xxx">canMSG_xxx</a> flags, so more than one bit might be set.</p>
<p>The size of the queues in the driver and hardware is descibed in <a class="el" href="page_user_guide_send_recv.html#section_user_guide_send_recv_queue_and_buf_sizes">Message Queue and Buffer Sizes</a>.</p>
<p>Sometimes it is desirable to have a peek into the more remote parts of the queue. Is there, for example, any message waiting that has a certain identifier? You can call <a class="el" href="group___c_a_n.html#gafb5e475233ef14ccf9084f610caba560">canReadSpecific</a> to read that message. Messages not matching the specified identifier will be kept in the queue and will be returned on the next call to <a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead</a>.</p>
<p>If you want to read just a message with a specified identifier, and throw all others away, you can call <a class="el" href="group___c_a_n.html#ga0eecb6695653d4dc6a4c0bb884a1b261">canReadSpecificSkip()</a>. This routine will return the first message with the specified identifier, discarding any other message in front of the desired one.</p>
<p>If you want to wait until a message arrives (or a timeout occurs) and then read it, call <a class="el" href="group___c_a_n.html#gac01f98e282609b5f6aaf2b1eabfb83ec">canReadWait()</a>.</p>
<p>If you want just to wait for an arbitrary message to arrive, but you don't want to read the message, call <a class="el" href="group___c_a_n.html#ga16356f4d646240ff2e640773d21f4d76">canReadSync()</a>.</p>
<p>If you want to wait until there is at least one message in the queue with a certain identifier, but you don't want to read it, call <a class="el" href="group___c_a_n.html#ga4b21a0e2547c1435c378d13e6803acef">canReadSyncSpecific()</a>.</p>
<p>You can specify a timeout (in milliseconds) for those routines that wait for messages.</p>
<p><b>Example</b>. Input Queue Handling</p>
<p>As an illustration of the abovementioned routines, consider the case where CAN messages with the following identifiers have arrived to the input queue:</p>
<p>1, 2, 3, 4, 5, 6, 7, 8, 9, 10</p>
<ol type="1">
<li><a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead</a>(hnd, &amp;id, ...) returns <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> and id == 1.</li>
<li><a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead</a>(hnd, &amp;id, ...) returns <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> and id == 2.</li>
<li><a class="el" href="group___c_a_n.html#gafb5e475233ef14ccf9084f610caba560">canReadSpecific</a>(hnd, 7, ...) returns <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> and the message with id 7.</li>
<li><a class="el" href="group___c_a_n.html#gafb5e475233ef14ccf9084f610caba560">canReadSpecific</a>(hnd, 7, ...) returns <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a734089f351bc421c230bf8b6cd9b1e8e">canERR_NOMSG</a>.</li>
<li><a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead</a>(hnd, &amp;id, ...) returns <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> and id == 3.</li>
<li><a class="el" href="group___c_a_n.html#ga0eecb6695653d4dc6a4c0bb884a1b261">canReadSpecificSkip</a>(hnd, 5, ...) returns <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> and the message with id 5.</li>
<li><a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead</a>(hnd, &amp;id, ...) returns <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> and id == 6.</li>
<li><a class="el" href="group___c_a_n.html#ga4b21a0e2547c1435c378d13e6803acef">canReadSyncSpecific</a>(hnd, 7, ..., 500) will wait for the next message with id=7 (or 500 ms have elapsed) and return <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> or <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7acd1c4c3a87dd24f0a43753ee4bfe7993">canERR_TIMEOUT</a>.</li>
<li><a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead</a>(hnd, &amp;id, ...) returns <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> and id == 8.</li>
<li><a class="el" href="group___c_a_n.html#gafb5e475233ef14ccf9084f610caba560">canReadSpecific</a>(hnd, 7, ...) returns <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a> and the message with id = 7, if the previous call to <a class="el" href="group___c_a_n.html#ga4b21a0e2547c1435c378d13e6803acef">canReadSyncSpecific()</a> returned <a class="el" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a>.</li>
</ol>
<h1><a class="anchor" id="section_user_guide_send_recv_sending"></a>
Sending Messages</h1>
<p>Outgoing CAN messages are buffered in a transmit queue and sent on a First-In First-Out basis. Use <a class="el" href="group___c_a_n.html#ga62c185329d6741c90102511e2f37983e">canWrite()</a> to send a message on the bus.</p>
<p>You can use <a class="el" href="group___c_a_n.html#ga304cb3a7bc2874c1f8ad361a911bcd5f">canWriteSync()</a> to wait until the messages in the queue have been sent.</p>
<p><b>Example</b>. Sending a CAN message.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> msg[8];</div><div class="line">...</div><div class="line">stat = <a class="code" href="group___c_a_n.html#ga62c185329d6741c90102511e2f37983e">canWrite</a>(hnd, 234, msg, 8, 0);</div></div><!-- fragment --><p><b>Using Extended CAN (CAN 2.0B)</b></p>
<p>"Standard" CAN has 11-bit identifiers in the range 0 - 2047. "Extended" CAN, also called CAN 2.0B, has 29-bit identifiers. You specify which kind of identifiers you want to use in your call to <a class="el" href="group___c_a_n.html#ga62c185329d6741c90102511e2f37983e">canWrite()</a>: if you set the <a class="el" href="canstat_8h.html#ade936f23b4b303d64187b4c6589c9c10">canMSG_EXT</a> flag in the flag argument, the message will be transmitted with a 29-bit identifier. Conversely, received 29-bit-identifier messages have the <a class="el" href="canstat_8h.html#ade936f23b4b303d64187b4c6589c9c10">canMSG_EXT</a> flag set.</p>
<dl class="section note"><dt>Note</dt><dd>Not all CAN controllers support CAN 2.0B.</dd></dl>
<p><b>Example</b>. Sending a CAN message using extended CAN.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> msg[8];</div><div class="line">...</div><div class="line">stat = <a class="code" href="group___c_a_n.html#ga62c185329d6741c90102511e2f37983e">canWrite</a>(hnd, 23456, msg, 8, <a class="code" href="canstat_8h.html#ade936f23b4b303d64187b4c6589c9c10">canMSG_EXT</a>);</div></div><!-- fragment --><h1><a class="anchor" id="section_user_guide_send_recv_asynch_not"></a>
Asynchronous Notification</h1>
<h2>Receiving Asynchronous Notification</h2>
<p>You can receive an asynchronous notification when certain events occur in CANlib, for example, when a message arrives or when the CAN controller goes "error passive" due to bus errors. Use <a class="el" href="group___c_a_n.html#gaa5dd0f277c7059169055321fbda87486">canSetNotify()</a> to tell CANlib what events you want notifications for. The different kinds of events are described below.</p>
<p>When the specified kind of event occur, the callback function that was specified in the call to <a class="el" href="group___c_a_n.html#gaa5dd0f277c7059169055321fbda87486">canSetNotify()</a> is called. The callback receives a pointer to a <a class="el" href="structcan_notify_data.html">canNotifyData</a> struct; its contents vary depending on the kind of event and is described below.</p>
<p><b>Receive Events</b><br />
 A receive event occurs when a CAN message arrives to a previously empty queue. In other words, there will be a receive event when the queue needs servicing but you will not receive an event for every received CAN message. The <a class="el" href="structcan_notify_data.html">canNotifyData</a> eventType field will be set to <a class="el" href="canstat_8h.html#af5f5917ba5476570815747b960e26ba6">canEVENT_RX</a>, and the <code>rx.id</code> and r<code>x.time</code> fields will be set to the message ID and timestamp.</p>
<p><b>Transmit Events</b><br />
 A transmit event occurs whenever a CAN message has been transmitted. The <a class="el" href="structcan_notify_data.html">canNotifyData</a> eventType field will be set to <a class="el" href="canstat_8h.html#a21669303d34190235f63303deae6b248">canEVENT_TX</a>, and the <code>tx.id</code> and <code>tx.time</code> fields will be set to the message ID and timestamp.</p>
<p><b>Status Events</b><br />
 A status event occurs when the bus status of the CAN controller has changed, for example, if the controller goes "error passive" due to bus errors. The <a class="el" href="structcan_notify_data.html">canNotifyData</a> eventType field will be set to <a class="el" href="canstat_8h.html#a0c59f7bbcb5cceaefe0d1d5915e8b4fc">canEVENT_STATUS</a>. The <code>info.status.busStatus</code>, <code>info.status.txErrorCounter</code>, <code>info.status.rxErrorCounter</code>, and info.status.time field will be set to status information.</p>
<p><b>Error Events</b><br />
 An error frame has been received. The <a class="el" href="structcan_notify_data.html">canNotifyData</a> eventType field will be set to <a class="el" href="canstat_8h.html#a5a6431078d49d8f7cc36c6313db44406">canEVENT_ERROR</a>, and the <code>info.busErr.time</code> field will be set to the error timestamp.</p>
<h2>Receiving Asynchronous Notification Using a Callback Function</h2>
<p>You can call the <a class="el" href="group__can__general.html#ga99976c5b8e2c534b27bf9ec2e715d8d3">kvSetNotifyCallback()</a> function to register a callback that is called by CANlib when certain events occur. The callback function is called in the context of a high-priority thread created by CANlib. You should be careful not to perform any time consuming tasks within the callback function, and you must also arrange for the synchronization between the callback function and the rest of your code.</p>
<h1><a class="anchor" id="section_user_guide_send_recv_filters"></a>
Message Filters</h1>
<h2>Setting Acceptance Filters</h2>
<p>You can set filters to reduce the number of received messages. CANlib supports setting of the hardware filters on the CAN interface board. This is done with the <a class="el" href="group___c_a_n.html#gaa4ffd2fad1932ad5763c2c923a1a12d8">canAccept()</a> function.</p>
<p>You set an acceptance code and an acceptance mask which together determine which CAN identifiers are accepted or rejected.</p>
<p><b>Example</b>. Setting the acceptance filters. </p><div class="fragment"><div class="line">stat = <a class="code" href="group___c_a_n.html#gaa4ffd2fad1932ad5763c2c923a1a12d8">canAccept</a>(hnd, 0xE7, <a class="code" href="canlib_8h.html#a9485f417c3629b9eb72d673b3ff16a5f">canFILTER_SET_CODE_STD</a>);</div><div class="line">stat = <a class="code" href="group___c_a_n.html#gaa4ffd2fad1932ad5763c2c923a1a12d8">canAccept</a>(hnd, 0xFF, <a class="code" href="canlib_8h.html#a8665c92e40adccfacc238af38b39f37e">canFILTER_SET_MASK_STD</a>);</div></div><!-- fragment --><p>This code snippet will cause all messages with 11-bit identifiers with the lower 8 bits not equalling 0xe7 to be rejected.</p>
<h1><a class="anchor" id="section_user_guide_send_recv_mailboxes"></a>
Message Mailboxes</h1>
<p>Some other CAN driver libraries in the market feature what usually is called "mailboxes", "message objects", "user buffers" etc. CANlib, on the other hand, focuses on message queues because we feel this imposes fewer restrictions on the CAN system.</p>
<p>For example, a higher layer protocol that uses a sequence of CAN messages with the same identifier is hard to implement using mailboxes: when the next message arrives it overwrites the previous one. You can, in a way, simulate the behavior of mailboxes by using <a class="el" href="group___c_a_n.html#gafb5e475233ef14ccf9084f610caba560">canReadSpecific()</a>. You will have to call <a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead()</a> periodically in order to clear out messages not read by <a class="el" href="group___c_a_n.html#gafb5e475233ef14ccf9084f610caba560">canReadSpecific()</a>.</p>
<p><b>Example</b>. How to simulate a mailbox-style CAN interface.</p>
<p>Assume you take special interest in CAN messages with identifiers 530, 540 and 550. Your message-handling loop could then look something like this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (..) {</div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group___c_a_n.html#gafb5e475233ef14ccf9084f610caba560">canReadSpecific</a>(hnd, 530, buf, ...) == <a class="code" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a>) {</div><div class="line">    <span class="comment">// Process msg 530</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group___c_a_n.html#gafb5e475233ef14ccf9084f610caba560">canReadSpecific</a>(hnd, 540, buf, ...) == <a class="code" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a>) {</div><div class="line">    <span class="comment">// Process msg 540</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group___c_a_n.html#gafb5e475233ef14ccf9084f610caba560">canReadSpecific</a>(hnd, 550, buf, ...) == <a class="code" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a>) {</div><div class="line">    <span class="comment">// Process msg 550</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span> (<a class="code" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead</a>(hnd, &amp;<span class="keywordtype">id</span>, buf, ...) == <a class="code" href="canstat_8h.html#a52b5e5c71832b0bd3c6a5b1fd48583e7a49743d0d438957118b9c6af2e831b209">canOK</a>) {</div><div class="line">    <span class="comment">// Handle other messages</span></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>You can call this message-processing routine from your <code>WM__CANLIB</code> handler or make it the main routine in your program.</p>
<h1><a class="anchor" id="section_user_guide_send_recv_overruns"></a>
Overruns</h1>
<p>If the CAN interface or the driver runs out of buffer space, or if the bus load is so high that the CAN controller can't keep up with the traffic, an overload condition is flagged to the application.</p>
<p>The driver will set the <a class="el" href="canstat_8h.html#ae441634e38d57eb789936f5ac745410b">canMSGERR_HW_OVERRUN</a> and/or <a class="el" href="canstat_8h.html#a810afd58f22df8c44c729f78d955e006">canMSGERR_SW_OVERRUN</a> flags in the flag argument of <a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead</a> and its relatives. The flag(s) will be set in the first message read from the driver after the overrun or overload condition happened.</p>
<p>Your application should test for both these flags. You can use the constant <a class="el" href="canstat_8h.html#adf0d578c7b25ede29a9733da44f08ab3">canMSGERR_OVERRUN</a> for doing this.</p>
<h1><a class="anchor" id="section_user_guide_send_recv_queue_and_buf_sizes"></a>
Message Queue and Buffer Sizes</h1>
<p>Incoming and outgoing CAN messages can be buffered in three different places:</p><ul>
<li>In the CAN controller</li>
<li>On the CAN board</li>
<li>In the CAN driver (i.e. CANlib)</li>
</ul>
<p>The sizes of the first two buffers are clearly hardware dependent. You might find the following information useful.</p>
<p>Many CAN boards from KVASER uses the SJA1000 CAN controller. This chip can buffer somewhere between 5 and 19 incoming messages. It does not buffer outgoing messages.</p>
<p>CAN boards with an on-board microcontroller (LAPcan, LAPcan II, USBcan) typically buffer something like 500 incoming and outgoing messages.</p>
<p>CAN boards using the M16C microcontroller (USBcan Rugged, USBcan II, PCIcan II) typically buffer some 100 incoming messages and around 50 outgoing messages.</p>
<p>CANlib <em>drivers</em> will, by default, buffer 256 outgoing messages per channel and 1024 incoming messages per channel. You can use <a class="el" href="group__can__general.html#gaeaa24db97af22478ca51d48636c7bb12">canIoCtl()</a> to adjust the size of the receive buffer.</p>
<h1><a class="anchor" id="section_user_guide_send_recv_obj_buf"></a>
Object Buffers</h1>
<p>CANlib supports object buffers for special purposes. You don't need these object buffers when transmitting and receiving regular messages. Instead, the object buffers allows you to</p><ul>
<li>define auto response messages; that is, when a message meeting a certain condition is received, CANlib will respond automatically with a message you define,</li>
<li>define auto transmit messages; that is, messages that are transmitted periodically.</li>
</ul>
<p>The object buffers are implemented by the firmware and hardware of certain devices, e.g. the Kvaser Leaf Professional. The number of buffers in a device is limited. Typically around 10 buffers are available.</p>
<p><b>Using the object buffers</b><br />
 To use the object buffers, you start with allocating a buffer with a call to <a class="el" href="group___object_buffers.html#gaa189a35c78004d037eed4bd0c2bfa3ee">canObjBufAllocate()</a>. For an auto response buffer, you define which messages to respond to by calling <a class="el" href="group___object_buffers.html#gaccca9d669c981e910c1805614ee40e72">canObjBufSetFilter()</a>, and the contents of the response is set with <a class="el" href="group___object_buffers.html#gad72611f11b4947c96c8d0b50f59b2173">canObjBufWrite()</a>.</p>
<p>To enable a buffer, call <a class="el" href="group___object_buffers.html#ga1ff3e82f6d0e9795a831e22183c6e7ec">canObjBufEnable()</a>, and call <a class="el" href="group___object_buffers.html#gab1238b563ecf4523092ebe561ece87ea">canObjBufDisable()</a> to disable it.</p>
<p>For an auto transmit buffer, call <a class="el" href="group___object_buffers.html#gaa23baa37921bf089d9123eb97f32541b">canObjBufSetPeriod()</a> to set the frequency of the message, call <a class="el" href="group___object_buffers.html#ga769ce97c3b7f3a8e246f872d7dbafe54">canObjBufSetMsgCount()</a> to set the number of messages to send from the buffer, and call <a class="el" href="group___object_buffers.html#gad72611f11b4947c96c8d0b50f59b2173">canObjBufWrite()</a> to define the contents of the message.</p>
<p>If you want to send a burst of messages at the highest possible pace, use <a class="el" href="group___object_buffers.html#gae3e27cd339700f26897648895e1b37a0">canObjBufSendBurst()</a>.</p>
<p>You deallocate a buffer that you don't want to use any longer by a call to <a class="el" href="group___object_buffers.html#ga7353b3671b897e1f33b88f9084857382">canObjBufFree()</a>. You can deallocate all buffers in one call with <a class="el" href="group___object_buffers.html#gab299ecf20aa368b8ee253ba9610dff3b">canObjBufFreeAll()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___object_buffers.html#gab299ecf20aa368b8ee253ba9610dff3b">canObjBufFreeAll()</a> </dd>
<dd>
<a class="el" href="group___object_buffers.html#gaa189a35c78004d037eed4bd0c2bfa3ee">canObjBufAllocate()</a> </dd>
<dd>
<a class="el" href="group___object_buffers.html#ga7353b3671b897e1f33b88f9084857382">canObjBufFree()</a> </dd>
<dd>
<a class="el" href="group___object_buffers.html#gad72611f11b4947c96c8d0b50f59b2173">canObjBufWrite()</a> </dd>
<dd>
<a class="el" href="group___object_buffers.html#gaccca9d669c981e910c1805614ee40e72">canObjBufSetFilter()</a> </dd>
<dd>
<a class="el" href="group___object_buffers.html#ga9369c2f47886d9f815fe5513d6f5b60b">canObjBufSetFlags()</a> </dd>
<dd>
<a class="el" href="group___object_buffers.html#ga1ff3e82f6d0e9795a831e22183c6e7ec">canObjBufEnable()</a> </dd>
<dd>
<a class="el" href="group___object_buffers.html#gab1238b563ecf4523092ebe561ece87ea">canObjBufDisable()</a> </dd>
<dd>
<a class="el" href="group___object_buffers.html#gae3e27cd339700f26897648895e1b37a0">canObjBufSendBurst()</a> </dd>
<dd>
<a class="el" href="group___object_buffers.html#gaa23baa37921bf089d9123eb97f32541b">canObjBufSetPeriod()</a> </dd>
<dd>
<a class="el" href="group___object_buffers.html#ga769ce97c3b7f3a8e246f872d7dbafe54">canObjBufSetMsgCount()</a></dd></dl>
<h1><a class="anchor" id="section_user_guide_send_recv_sending_different_types"></a>
Different CAN Frame Types</h1>
<h2>Remote Requests</h2>
<p>You can send remote requests by passing the <a class="el" href="canstat_8h.html#a687df04559a9995e0bec503655454eb3">canMSG_RTR</a> flag to <a class="el" href="group___c_a_n.html#ga62c185329d6741c90102511e2f37983e">canWrite()</a>. Received remote frames are reported by <a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead</a> et al using the same flag.</p>
<h2>Error Frames</h2>
<p>Nearly all hardware platforms support detection of error frames. If an error frame arrives, the flag <a class="el" href="canstat_8h.html#ade1b8ed815a4bc6ada6ec666e48e9cf8">canMSG_ERROR_FRAME</a> is set in the flag argument of <a class="el" href="group___c_a_n.html#ga157d49a9343dea68ac953145e02266d8">canRead()</a>. The identifier is garbage if an error frame is received, but for LAPcan it happens to be 2048 plus the error code from the SJA1000.</p>
<p>Many platforms (for example, LAPcan, Leaf, and USBcan II) support transmission of error frames as well. To send error frames, set the <a class="el" href="canstat_8h.html#ade1b8ed815a4bc6ada6ec666e48e9cf8">canMSG_ERROR_FRAME</a> flag in the flag argument to <a class="el" href="group___c_a_n.html#ga62c185329d6741c90102511e2f37983e">canWrite()</a>.</p>
<h2>Overload Frames</h2>
<p>These aren't used nowadays. Certain old CAN controllers (Intel 82526) used them to delay frame processing in certain cases.</p>
<h2>Other frame features of interest</h2>
<ul>
<li>You can send wakeup frames (used for Single-Wire CAN) if your hardware supports it, for example, a LAPcan plus a DRVcan S. Just set the <a class="el" href="canstat_8h.html#a616183e2ed8ca81976463914e47b35e1">canMSG_WAKEUP</a> flag when calling <a class="el" href="group___c_a_n.html#ga62c185329d6741c90102511e2f37983e">canWrite()</a>.</li>
<li>For "low-speed CAN" (1053/1054 type transceivers), the <a class="el" href="canstat_8h.html#a1f53f2fdeeb263cd2bf5d374e1dd59a2">canMSG_NERR</a> flag is set if a frame is received in "fault-tolerant" mode. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="page_canlib.html">CAN bus API (CANlib)</a></li><li class="navelem"><a class="el" href="page_user_guide.html">CANlib User&#39;s Guide</a></li>
    <li class="footer"> (canlib 5.25) Sun Sep 16 2018</li>
  </ul>
</div>
</body>
</html>
